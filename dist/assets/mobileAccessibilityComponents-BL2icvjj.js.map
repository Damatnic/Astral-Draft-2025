{"version":3,"file":"mobileAccessibilityComponents-BL2icvjj.js","sources":["../../utils/mobileAccessibilityUtils.ts","../../utils/mobileAccessibilityComponents.tsx"],"sourcesContent":["/**\n * Mobile Accessibility Utilities\n * Provides comprehensive accessibility testing and validation functionality\n */\n\nexport interface TouchTargetValidation {\n    isValid: boolean;\n    violations: string[];\n    touchTargets: {\n        element: Element;\n        size: { width: number; height: number };\n        isValid: boolean;\n        reason?: string;\n    }[];\n}\n\nexport interface AccessibilityAuditResult {\n    isValid: boolean;\n    violations: string[];\n    touchTargetValidation: TouchTargetValidation;\n    ariaValidation: {\n        isValid: boolean;\n        violations: string[];\n    };\n    colorContrastValidation: {\n        isValid: boolean;\n        violations: string[];\n    };\n}\n\nexport interface ColorContrastResult {\n    isValid: boolean;\n    ratio: number;\n    level: 'AA' | 'AAA' | 'FAIL';\n    backgroundColor: string;\n    foregroundColor: string;\n}\n\n/**\n * Comprehensive accessibility testing utility\n */\nexport class AccessibilityTester {\n    private readonly MINIMUM_TOUCH_TARGET = 44; // 44px minimum per WCAG guidelines\n    private readonly AA_CONTRAST_RATIO = 4.5;\n    private readonly AAA_CONTRAST_RATIO = 7;\n\n    /**\n     * Validate touch targets meet accessibility standards\n     */\n    validateTouchTargets(container: Element): TouchTargetValidation {\n        const interactiveElements = container.querySelectorAll(\n            'button, a, input, select, textarea, [role=\"button\"], [role=\"link\"], [tabindex=\"0\"]'\n        );\n\n        const touchTargets: TouchTargetValidation['touchTargets'] = [];\n        const violations: string[] = [];\n\n        interactiveElements.forEach((element) => {\n            const rect = element.getBoundingClientRect();\n            const size = { width: rect.width, height: rect.height };\n            \n            const isValid = size.width >= this.MINIMUM_TOUCH_TARGET && size.height >= this.MINIMUM_TOUCH_TARGET;\n            \n            touchTargets.push({\n                element,\n                size,\n                isValid,\n                reason: !isValid ? `Touch target too small: ${size.width}x${size.height}px (minimum: ${this.MINIMUM_TOUCH_TARGET}px)` : undefined\n            });\n\n            if (!isValid) {\n                violations.push(`Element ${element.tagName} has insufficient touch target size: ${size.width}x${size.height}px`);\n            }\n        });\n\n        return {\n            isValid: violations.length === 0,\n            violations,\n            touchTargets\n        };\n    }\n\n    /**\n     * Check color contrast between background and foreground colors\n     */\n    checkColorContrast(backgroundColor: string, foregroundColor: string): ColorContrastResult {\n        const bgLuminance = this.calculateLuminance(backgroundColor);\n        const fgLuminance = this.calculateLuminance(foregroundColor);\n        \n        const ratio = (Math.max(bgLuminance, fgLuminance) + 0.05) / (Math.min(bgLuminance, fgLuminance) + 0.05);\n        \n        let level: 'AA' | 'AAA' | 'FAIL';\n        if (ratio >= this.AAA_CONTRAST_RATIO) {\n            level = 'AAA';\n        } else if (ratio >= this.AA_CONTRAST_RATIO) {\n            level = 'AA';\n        } else {\n            level = 'FAIL';\n        }\n\n        return {\n            isValid: ratio >= this.AA_CONTRAST_RATIO,\n            ratio: Math.round(ratio * 100) / 100,\n            level,\n            backgroundColor,\n            foregroundColor\n        };\n    }\n\n    /**\n     * Run comprehensive accessibility audit\n     */\n    runAccessibilityAudit(container: Element): AccessibilityAuditResult {\n        const touchTargetValidation = this.validateTouchTargets(container);\n        const ariaValidation = this.validateAriaAttributes(container);\n        const colorContrastValidation = this.validateColorContrast(container);\n\n        const allViolations = [\n            ...touchTargetValidation.violations,\n            ...ariaValidation.violations,\n            ...colorContrastValidation.violations\n        ];\n\n        return {\n            isValid: allViolations.length === 0,\n            violations: allViolations,\n            touchTargetValidation,\n            ariaValidation,\n            colorContrastValidation\n        };\n    }\n\n    /**\n     * Validate ARIA attributes and labels\n     */\n    private validateAriaAttributes(container: Element): { isValid: boolean; violations: string[] } {\n        const violations: string[] = [];\n        \n        // Check for missing labels on form controls\n        const formControls = container.querySelectorAll('input, select, textarea');\n        formControls.forEach((control) => {\n            const hasLabel = control.getAttribute('aria-label') || \n                           control.getAttribute('aria-labelledby') ||\n                           container.querySelector(`label[for=\"${control.id}\"]`);\n            \n            if (!hasLabel) {\n                violations.push(`Form control ${control.tagName} missing accessible label`);\n            }\n        });\n\n        // Check for proper heading structure\n        const headings = container.querySelectorAll('h1, h2, h3, h4, h5, h6');\n        if (headings.length > 0) {\n            const levels = Array.from(headings).map(h => parseInt(h.tagName.charAt(1)));\n            for (let i = 1; i < levels.length; i++) {\n                if (levels[i] > levels[i - 1] + 1) {\n                    violations.push(`Heading level skipped: h${levels[i - 1]} to h${levels[i]}`);\n                }\n            }\n        }\n\n        return {\n            isValid: violations.length === 0,\n            violations\n        };\n    }\n\n    /**\n     * Validate color contrast throughout the container\n     */\n    private validateColorContrast(container: Element): { isValid: boolean; violations: string[] } {\n        const violations: string[] = [];\n        \n        // Check text elements for sufficient contrast\n        const textElements = container.querySelectorAll('*');\n        textElements.forEach((element) => {\n            const styles = window.getComputedStyle(element);\n            const hasText = element.textContent && element.textContent.trim().length > 0;\n            \n            if (hasText && styles.color && styles.backgroundColor) {\n                const contrast = this.checkColorContrast(styles.backgroundColor, styles.color);\n                if (!contrast.isValid) {\n                    violations.push(`Insufficient color contrast: ${contrast.ratio}:1 (minimum: ${this.AA_CONTRAST_RATIO}:1)`);\n                }\n            }\n        });\n\n        return {\n            isValid: violations.length === 0,\n            violations\n        };\n    }\n\n    /**\n     * Calculate relative luminance of a color\n     */\n    private calculateLuminance(color: string): number {\n        // Convert color to RGB values\n        const rgb = this.parseColor(color);\n        \n        // Convert RGB to relative luminance\n        const sRGB = rgb.map(value => {\n            const normalized = value / 255;\n            return normalized <= 0.03928 \n                ? normalized / 12.92 \n                : Math.pow((normalized + 0.055) / 1.055, 2.4);\n        });\n\n        return 0.2126 * sRGB[0] + 0.7152 * sRGB[1] + 0.0722 * sRGB[2];\n    }\n\n    /**\n     * Parse color string to RGB values\n     */\n    private parseColor(color: string): [number, number, number] {\n        // Create a temporary element to parse the color\n        const div = document.createElement('div');\n        div.style.color = color;\n        document.body.appendChild(div);\n        \n        const computed = window.getComputedStyle(div).color;\n        document.body.removeChild(div);\n        \n        // Parse rgb(r, g, b) format\n        const match = computed.match(/rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)/);\n        if (match) {\n            return [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])];\n        }\n        \n        // Fallback to black\n        return [0, 0, 0];\n    }\n}\n\n/**\n * Announce text to screen readers\n */\nexport function announceToScreenReader(message: string, priority: 'polite' | 'assertive' = 'polite'): void {\n    const announcement = document.createElement('div');\n    announcement.setAttribute('aria-live', priority);\n    announcement.setAttribute('aria-atomic', 'true');\n    announcement.className = 'sr-only';\n    announcement.textContent = message;\n    \n    document.body.appendChild(announcement);\n    \n    // Remove after announcement\n    setTimeout(() => {\n        document.body.removeChild(announcement);\n    }, 1000);\n}\n\n/**\n * Focus management utilities\n */\nexport const focusManagement = {\n    /**\n     * Trap focus within a container\n     */\n    trapFocus(container: Element): () => void {\n        const focusableElements = container.querySelectorAll(\n            'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\n        );\n        \n        const firstElement = focusableElements[0] as HTMLElement;\n        const lastElement = focusableElements[focusableElements.length - 1] as HTMLElement;\n\n        const handleTabKey = (e: Event) => {\n            const keyboardEvent = e as KeyboardEvent;\n            if (keyboardEvent.key === 'Tab') {\n                if (keyboardEvent.shiftKey) {\n                    if (document.activeElement === firstElement) {\n                        lastElement.focus();\n                        keyboardEvent.preventDefault();\n                    }\n                } else {\n                    if (document.activeElement === lastElement) {\n                        firstElement.focus();\n                        keyboardEvent.preventDefault();\n                    }\n                }\n            }\n        };\n\n        container.addEventListener('keydown', handleTabKey);\n        \n        // Focus first element\n        firstElement?.focus();\n\n        // Return cleanup function\n        return () => {\n            container.removeEventListener('keydown', handleTabKey);\n        };\n    },\n\n    /**\n     * Return focus to previous element\n     */\n    returnFocus(element: HTMLElement | null): void {\n        if (element && typeof element.focus === 'function') {\n            element.focus();\n        }\n    }\n};\n\n/**\n * ARIA utilities\n */\nexport const ariaUtils = {\n    /**\n     * Set expanded state for disclosure widgets\n     */\n    setExpanded(element: Element, isExpanded: boolean): void {\n        element.setAttribute('aria-expanded', isExpanded.toString());\n    },\n\n    /**\n     * Set selected state for selectable items\n     */\n    setSelected(element: Element, isSelected: boolean): void {\n        element.setAttribute('aria-selected', isSelected.toString());\n    },\n\n    /**\n     * Set pressed state for toggle buttons\n     */\n    setPressed(element: Element, isPressed: boolean): void {\n        element.setAttribute('aria-pressed', isPressed.toString());\n    },\n\n    /**\n     * Update live region content\n     */\n    updateLiveRegion(regionId: string, content: string, priority: 'polite' | 'assertive' = 'polite'): void {\n        const region = document.getElementById(regionId);\n        if (region) {\n            region.setAttribute('aria-live', priority);\n            region.textContent = content;\n        }\n    }\n};\n\nexport default AccessibilityTester;\n\n/**\n * React hooks for accessibility\n */\n\nimport { useState, useEffect, useRef } from 'react';\n\n/**\n * Hook for keyboard navigation support\n */\nexport function useKeyboardNavigation(elementRef: React.RefObject<HTMLElement>) {\n    useEffect(() => {\n        const element = elementRef.current;\n        if (!element) return;\n\n        const handleKeyDown = (e: KeyboardEvent) => {\n            switch (e.key) {\n                case 'Escape':\n                    element.blur();\n                    break;\n                case 'Enter':\n                case ' ':\n                    if (element.tagName === 'BUTTON' || element.getAttribute('role') === 'button') {\n                        e.preventDefault();\n                        element.click();\n                    }\n                    break;\n            }\n        };\n\n        element.addEventListener('keydown', handleKeyDown);\n        return () => element.removeEventListener('keydown', handleKeyDown);\n    }, [elementRef]);\n}\n\n/**\n * Hook for focus management\n */\nexport function useFocusManagement() {\n    const focusRef = useRef<HTMLElement | null>(null);\n\n    const trapFocus = (container: HTMLElement) => {\n        return focusManagement.trapFocus(container);\n    };\n\n    const returnFocus = () => {\n        focusManagement.returnFocus(focusRef.current);\n    };\n\n    const saveFocus = () => {\n        focusRef.current = document.activeElement as HTMLElement;\n    };\n\n    return { trapFocus, returnFocus, saveFocus };\n}\n\n/**\n * Hook for reduced motion preference\n */\nexport function useReducedMotion(): boolean {\n    const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n\n    useEffect(() => {\n        const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n        setPrefersReducedMotion(mediaQuery.matches);\n\n        const handleChange = () => setPrefersReducedMotion(mediaQuery.matches);\n        mediaQuery.addEventListener('change', handleChange);\n\n        return () => mediaQuery.removeEventListener('change', handleChange);\n    }, []);\n\n    return prefersReducedMotion;\n}\n","/**\n * Accessible Mobile Components\n * React components with built-in accessibility features\n */\n\nimport React, { useRef } from 'react';\nimport { useKeyboardNavigation } from './mobileAccessibilityUtils';\n\n/**\n * Accessible button component\n */\ninterface AccessibleButtonProps {\n    children: React.ReactNode;\n    onClick?: () => void;\n    disabled?: boolean;\n    ariaLabel?: string;\n    className?: string;\n    type?: 'button' | 'submit' | 'reset';\n}\n\nexport const AccessibleButton: React.FC<AccessibleButtonProps> = ({\n    children,\n    onClick,\n    disabled = false,\n    ariaLabel,\n    className = '',\n    type = 'button'\n}) => {\n    const buttonRef = useRef<HTMLButtonElement>(null);\n    useKeyboardNavigation(buttonRef as React.RefObject<HTMLElement>);\n\n    return (\n        <button\n            ref={buttonRef}\n            type={type}\n            onClick={onClick}\n            disabled={disabled}\n            aria-label={ariaLabel}\n            className={`${className} focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2`}\n        >\n            {children}\n        </button>\n    );\n};\n\n/**\n * Visually hidden component for screen readers\n */\ninterface VisuallyHiddenProps {\n    children: React.ReactNode;\n}\n\nexport const VisuallyHidden: React.FC<VisuallyHiddenProps> = ({ children }) => {\n    return (\n        <span className=\"sr-only absolute left-[-10000px] top-auto w-[1px] h-[1px] overflow-hidden\">\n            {children}\n        </span>\n    );\n};\n\n/**\n * Live region component for announcements\n */\ninterface LiveRegionProps {\n    children: React.ReactNode;\n    politeness?: 'polite' | 'assertive';\n    atomic?: boolean;\n    relevant?: 'all' | 'additions' | 'removals' | 'text' | 'additions text' | 'additions removals' | 'removals text' | 'text additions' | 'text removals' | 'removals additions';\n}\n\nexport const LiveRegion: React.FC<LiveRegionProps> = ({\n    children,\n    politeness = 'polite',\n    atomic = true,\n    relevant = 'all'\n}) => {\n    return (\n        <div\n            aria-live={politeness}\n            aria-atomic={atomic}\n            aria-relevant={relevant}\n            className=\"sr-only\"\n        >\n            {children}\n        </div>\n    );\n};\n"],"names":["announceToScreenReader","message","priority","announcement","useKeyboardNavigation","elementRef","useEffect","element","handleKeyDown","e","useReducedMotion","prefersReducedMotion","setPrefersReducedMotion","useState","mediaQuery","handleChange","VisuallyHidden","children","jsxDEV","this"],"mappings":"+CA6OO,SAASA,EAAuBC,EAAiBC,EAAmC,SAAgB,CACvG,MAAMC,EAAe,SAAS,cAAc,KAAK,EACjDA,EAAa,aAAa,YAAaD,CAAQ,EAC/CC,EAAa,aAAa,cAAe,MAAM,EAC/CA,EAAa,UAAY,UACzBA,EAAa,YAAcF,EAE3B,SAAS,KAAK,YAAYE,CAAY,EAGtC,WAAW,IAAM,CACb,SAAS,KAAK,YAAYA,CAAY,CAC1C,EAAG,GAAI,CACX,CAuGO,SAASC,EAAsBC,EAA0C,CAC5EC,EAAAA,UAAU,IAAM,CACZ,MAAMC,EAAUF,EAAW,QAC3B,GAAI,CAACE,EAAS,OAEd,MAAMC,EAAiBC,GAAqB,CACxC,OAAQA,EAAE,IAAA,CACN,IAAK,SACDF,EAAQ,KAAA,EACR,MACJ,IAAK,QACL,IAAK,KACGA,EAAQ,UAAY,UAAYA,EAAQ,aAAa,MAAM,IAAM,YACjEE,EAAE,eAAA,EACFF,EAAQ,MAAA,GAEZ,KAAA,CAEZ,EAEA,OAAAA,EAAQ,iBAAiB,UAAWC,CAAa,EAC1C,IAAMD,EAAQ,oBAAoB,UAAWC,CAAa,CACrE,EAAG,CAACH,CAAU,CAAC,CACnB,CA0BO,SAASK,GAA4B,CACxC,KAAM,CAACC,EAAsBC,CAAuB,EAAIC,EAAAA,SAAS,EAAK,EAEtEP,OAAAA,EAAAA,UAAU,IAAM,CACZ,MAAMQ,EAAa,OAAO,WAAW,kCAAkC,EACvEF,EAAwBE,EAAW,OAAO,EAE1C,MAAMC,EAAe,IAAMH,EAAwBE,EAAW,OAAO,EACrE,OAAAA,EAAW,iBAAiB,SAAUC,CAAY,EAE3C,IAAMD,EAAW,oBAAoB,SAAUC,CAAY,CACtE,EAAG,CAAA,CAAE,EAEEJ,CACX,CC5WO,MAAMK,EAAgD,CAAC,CAAE,SAAAC,KAExDC,EAAAA,OAAC,OAAA,CAAK,UAAU,4EACX,SAAAD,CAAA,EADL,OAAA,GAAA,CAAA,SAAA,6EAAA,WAAA,GAAA,aAAA,CAAA,EAAAE,MAEA"}