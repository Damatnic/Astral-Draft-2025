{"version":3,"file":"useLiveData-ecYnbsuh.js","sources":["../../services/realTimeNflDataService.ts","../../services/oracleLiveDataIntegrationService.ts","../../services/liveDataService.ts","../../hooks/useLiveData.ts"],"sourcesContent":["/**\n * Real-Time NFL Data Service\n * Provides live NFL data feeds with WebSocket streaming for Oracle ML integration\n * Integrates ESPN API, NFL API, and weather services for comprehensive real-time data\n */\n\nimport { productionSportsDataService } from './productionSportsDataService';\nimport type { NFLGame, NFLPlayer } from './productionSportsDataService';\n\n// Real-time data event types\nexport type RealTimeEventType = \n  | 'GAME_START' \n  | 'SCORE_UPDATE' \n  | 'PLAYER_INJURY' \n  | 'PLAYER_STATUS_CHANGE'\n  | 'WEATHER_UPDATE'\n  | 'ODDS_UPDATE'\n  | 'QUARTER_END'\n  | 'GAME_END'\n  | 'TIMEOUT'\n  | 'PENALTY'\n  | 'TURNOVER'\n  | 'RED_ZONE_ENTRY';\n\nexport interface RealTimeGameEvent {\n  id: string;\n  type: RealTimeEventType;\n  gameId: string;\n  timestamp: number;\n  data: {\n    quarter?: number;\n    timeRemaining?: string;\n    homeScore?: number;\n    awayScore?: number;\n    playerId?: string;\n    playerName?: string;\n    team?: string;\n    description: string;\n    severity?: 'low' | 'medium' | 'high' | 'critical';\n    impact?: 'positive' | 'negative' | 'neutral';\n  };\n}\n\nexport interface LivePlayerUpdate {\n  playerId: string;\n  name: string;\n  team: string;\n  position: string;\n  gameId: string;\n  stats: {\n    passingYards?: number;\n    passingTouchdowns?: number;\n    rushingYards?: number;\n    rushingTouchdowns?: number;\n    receivingYards?: number;\n    receivingTouchdowns?: number;\n    receptions?: number;\n    fantasyPoints: number;\n  };\n  injuryStatus: 'healthy' | 'questionable' | 'doubtful' | 'out';\n  lastUpdated: number;\n}\n\nexport interface LiveGameData {\n  game: NFLGame;\n  events: RealTimeGameEvent[];\n  playerUpdates: LivePlayerUpdate[];\n  lastUpdated: number;\n}\n\nexport interface OracleDataUpdate {\n  type: 'prediction_confidence_change' | 'new_data_available' | 'model_recalibration';\n  data: {\n    affectedPredictions: string[];\n    confidenceChanges: { [predictionId: string]: number };\n    newDataSources: string[];\n    timestamp: number;\n  };\n}\n\n// WebSocket connection interface\ninterface WebSocketConnection {\n  socket: WebSocket | null;\n  isConnected: boolean;\n  reconnectAttempts: number;\n  subscriptions: Set<string>;\n}\n\nclass RealTimeNflDataService {\n  private readonly wsConnection: WebSocketConnection = {\n    socket: null,\n    isConnected: false,\n    reconnectAttempts: 0,\n    subscriptions: new Set()\n  };\n\n  private readonly gameDataCache = new Map<string, LiveGameData>();\n  private readonly playerDataCache = new Map<string, LivePlayerUpdate>();\n  private readonly eventListeners = new Map<string, Set<(data: any) => void>>();\n  \n  // Polling intervals for different data types\n  private intervals: { [key: string]: NodeJS.Timeout } = {};\n  private readonly GAME_POLLING_INTERVAL = 10000; // 10 seconds for live games\n  private readonly PLAYER_POLLING_INTERVAL = 30000; // 30 seconds for player stats\n  private readonly ODDS_POLLING_INTERVAL = 120000; // 2 minutes for odds\n\n  private readonly MAX_RECONNECT_ATTEMPTS = 5;\n  private readonly RECONNECT_DELAY = 5000;\n\n  constructor() {\n    this.initializeConnection();\n  }\n\n  /**\n   * Initialize WebSocket connection for real-time updates\n   */\n  private initializeConnection(): void {\n    // In production, this would connect to a real WebSocket server\n    // For now, we'll use polling as a fallback with simulation of WebSocket events\n    console.log('üîÑ Initializing real-time NFL data connection...');\n    \n    // Simulate WebSocket connection\n    this.wsConnection.isConnected = true;\n    this.wsConnection.reconnectAttempts = 0;\n    \n    // Start polling for live data\n    this.startPolling();\n  }\n\n  /**\n   * Start polling for different types of data\n   */\n  private startPolling(): void {\n    // Poll for live game data during active games\n    this.intervals.games = setInterval(() => {\n      this.pollLiveGames();\n    }, this.GAME_POLLING_INTERVAL);\n\n    // Poll for player updates\n    this.intervals.players = setInterval(() => {\n      this.pollPlayerUpdates();\n    }, this.PLAYER_POLLING_INTERVAL);\n\n    // Poll for odds updates\n    this.intervals.odds = setInterval(() => {\n      this.pollOddsUpdates();\n    }, this.ODDS_POLLING_INTERVAL);\n  }\n\n  /**\n   * Poll for live game data and emit events\n   */\n  private async pollLiveGames(): Promise<void> {\n    try {\n      const liveGames = await productionSportsDataService.getLiveScores();\n      \n      for (const game of liveGames) {\n        const cachedGame = this.gameDataCache.get(game.id);\n        \n        if (!cachedGame || this.hasGameChanged(cachedGame.game, game)) {\n          const events = this.generateGameEvents(cachedGame?.game, game);\n          const playerUpdates = await this.getPlayerUpdatesForGame(game.id);\n          \n          const liveGameData: LiveGameData = {\n            game,\n            events,\n            playerUpdates,\n            lastUpdated: Date.now()\n          };\n          \n          this.gameDataCache.set(game.id, liveGameData);\n          \n          // Emit game events\n          events.forEach(event => {\n            this.emit('game_event', event);\n          });\n          \n          // Emit score updates\n          if (events.some(e => e.type === 'SCORE_UPDATE')) {\n            this.emit('score_update', {\n              gameId: game.id,\n              homeScore: game.homeScore,\n              awayScore: game.awayScore,\n              timestamp: Date.now()\n            });\n          }\n        }\n      }\n    } catch (error) {\n      console.error('‚ùå Error polling live games:', error);\n    }\n  }\n\n  /**\n   * Poll for player status updates\n   */\n  private async pollPlayerUpdates(): Promise<void> {\n    try {\n      const playerUpdates = await productionSportsDataService.getPlayerUpdates();\n      \n      for (const player of playerUpdates) {\n        const cached = this.playerDataCache.get(player.id);\n        \n        if (!cached || this.hasPlayerChanged(cached, player)) {\n          const liveUpdate: LivePlayerUpdate = {\n            playerId: player.id,\n            name: player.name,\n            team: player.team,\n            position: player.position,\n            gameId: this.findPlayerGameId(player.id),\n            stats: {\n              passingYards: player.stats.passingYards,\n              passingTouchdowns: player.stats.passingTouchdowns,\n              rushingYards: player.stats.rushingYards,\n              rushingTouchdowns: player.stats.rushingTouchdowns,\n              receivingYards: player.stats.receivingYards,\n              receivingTouchdowns: player.stats.receivingTouchdowns,\n              receptions: player.stats.receptions,\n              fantasyPoints: player.stats.fantasyPoints || 0\n            },\n            injuryStatus: player.injuryStatus || 'healthy',\n            lastUpdated: Date.now()\n          };\n          \n          this.playerDataCache.set(player.id, liveUpdate);\n          \n          // Generate player update events\n          if (cached && cached.injuryStatus !== liveUpdate.injuryStatus) {\n            this.emit('player_injury', {\n              playerId: player.id,\n              name: player.name,\n              team: player.team,\n              oldStatus: cached.injuryStatus,\n              newStatus: liveUpdate.injuryStatus,\n              timestamp: Date.now()\n            });\n          }\n          \n          this.emit('player_update', liveUpdate);\n        }\n      }\n    } catch (error) {\n      console.error('‚ùå Error polling player updates:', error);\n    }\n  }\n\n  /**\n   * Poll for odds updates\n   */\n  private async pollOddsUpdates(): Promise<void> {\n    try {\n      const games = await productionSportsDataService.getCurrentWeekGames();\n      \n      for (const game of games) {\n        if (game.odds) {\n          this.emit('odds_update', {\n            gameId: game.id,\n            odds: game.odds,\n            timestamp: Date.now()\n          });\n        }\n      }\n    } catch (error) {\n      console.error('‚ùå Error polling odds updates:', error);\n    }\n  }\n\n  /**\n   * Check if game data has changed\n   */\n  private hasGameChanged(oldGame: NFLGame | undefined, newGame: NFLGame): boolean {\n    if (!oldGame) return true;\n    \n    return (\n      oldGame.homeScore !== newGame.homeScore ||\n      oldGame.awayScore !== newGame.awayScore ||\n      oldGame.status !== newGame.status\n    );\n  }\n\n  /**\n   * Check if player data has changed\n   */\n  private hasPlayerChanged(oldPlayer: LivePlayerUpdate, newPlayer: NFLPlayer): boolean {\n    return (\n      oldPlayer.injuryStatus !== (newPlayer.injuryStatus || 'healthy') ||\n      oldPlayer.stats.fantasyPoints !== (newPlayer.stats.fantasyPoints || 0)\n    );\n  }\n\n  /**\n   * Generate game events based on changes\n   */\n  private generateGameEvents(oldGame: NFLGame | undefined, newGame: NFLGame): RealTimeGameEvent[] {\n    const events: RealTimeGameEvent[] = [];\n    \n    if (!oldGame) {\n      // New game started\n      if (newGame.status === 'live') {\n        events.push({\n          id: `${newGame.id}_start_${Date.now()}`,\n          type: 'GAME_START',\n          gameId: newGame.id,\n          timestamp: Date.now(),\n          data: {\n            description: `${newGame.awayTeam.name} @ ${newGame.homeTeam.name} has started`,\n            impact: 'neutral'\n          }\n        });\n      }\n    } else {\n      // Score changes\n      if (oldGame.homeScore !== newGame.homeScore || oldGame.awayScore !== newGame.awayScore) {\n        events.push({\n          id: `${newGame.id}_score_${Date.now()}`,\n          type: 'SCORE_UPDATE',\n          gameId: newGame.id,\n          timestamp: Date.now(),\n          data: {\n            homeScore: newGame.homeScore,\n            awayScore: newGame.awayScore,\n            description: `Score Update: ${newGame.awayTeam.abbreviation} ${newGame.awayScore} - ${newGame.homeTeam.abbreviation} ${newGame.homeScore}`,\n            impact: 'positive'\n          }\n        });\n      }\n      \n      // Game status changes\n      if (oldGame.status !== newGame.status && newGame.status === 'completed') {\n        events.push({\n          id: `${newGame.id}_end_${Date.now()}`,\n          type: 'GAME_END',\n          gameId: newGame.id,\n          timestamp: Date.now(),\n          data: {\n            homeScore: newGame.homeScore,\n            awayScore: newGame.awayScore,\n            description: `Final: ${newGame.awayTeam.abbreviation} ${newGame.awayScore} - ${newGame.homeTeam.abbreviation} ${newGame.homeScore}`,\n            impact: 'neutral'\n          }\n        });\n      }\n    }\n    \n    return events;\n  }\n\n  /**\n   * Find the current game ID for a player\n   */\n  private findPlayerGameId(playerId: string): string {\n    // This would lookup current game for player from API\n    // For now, return a placeholder\n    return `game_week_${this.getCurrentWeek()}_${playerId.substring(0, 8)}`;\n  }\n\n  /**\n   * Get player updates for a specific game\n   */\n  private async getPlayerUpdatesForGame(gameId: string): Promise<LivePlayerUpdate[]> {\n    try {\n      const allPlayers = await productionSportsDataService.getPlayerUpdates();\n      return allPlayers\n        .filter(player => this.findPlayerGameId(player.id) === gameId)\n        .map(player => ({\n          playerId: player.id,\n          name: player.name,\n          team: player.team,\n          position: player.position,\n          gameId,\n          stats: {\n            passingYards: player.stats.passingYards,\n            passingTouchdowns: player.stats.passingTouchdowns,\n            rushingYards: player.stats.rushingYards,\n            rushingTouchdowns: player.stats.rushingTouchdowns,\n            receivingYards: player.stats.receivingYards,\n            receivingTouchdowns: player.stats.receivingTouchdowns,\n            receptions: player.stats.receptions,\n            fantasyPoints: player.stats.fantasyPoints || 0\n          },\n          injuryStatus: player.injuryStatus || 'healthy',\n          lastUpdated: Date.now()\n        }));\n    } catch (error) {\n      console.error('‚ùå Error getting player updates for game:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Get current NFL week\n   */\n  private getCurrentWeek(): number {\n    // Simple calculation for current week - in production this would be more sophisticated\n    const now = new Date();\n    const seasonStart = new Date(now.getFullYear(), 8, 1); // September 1st\n    const weeksSinceStart = Math.floor((now.getTime() - seasonStart.getTime()) / (7 * 24 * 60 * 60 * 1000));\n    return Math.min(Math.max(weeksSinceStart + 1, 1), 18);\n  }\n\n  /**\n   * Subscribe to real-time events\n   */\n  public subscribe(eventType: string, callback: (data: any) => void): void {\n    if (!this.eventListeners.has(eventType)) {\n      this.eventListeners.set(eventType, new Set());\n    }\n    const listeners = this.eventListeners.get(eventType);\n    if (listeners) {\n      listeners.add(callback);\n    }\n  }\n\n  /**\n   * Unsubscribe from real-time events\n   */\n  public unsubscribe(eventType: string, callback: (data: any) => void): void {\n    const listeners = this.eventListeners.get(eventType);\n    if (listeners) {\n      listeners.delete(callback);\n    }\n  }\n\n  /**\n   * Emit events to subscribers\n   */\n  private emit(eventType: string, data: any): void {\n    const listeners = this.eventListeners.get(eventType);\n    if (listeners) {\n      listeners.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error(`‚ùå Error in event listener for ${eventType}:`, error);\n        }\n      });\n    }\n  }\n\n  /**\n   * Get live data for specific game\n   */\n  public getLiveGameData(gameId: string): LiveGameData | null {\n    return this.gameDataCache.get(gameId) || null;\n  }\n\n  /**\n   * Get all live games\n   */\n  public getAllLiveGames(): LiveGameData[] {\n    return Array.from(this.gameDataCache.values());\n  }\n\n  /**\n   * Get player updates for specific player\n   */\n  public getPlayerUpdate(playerId: string): LivePlayerUpdate | null {\n    return this.playerDataCache.get(playerId) || null;\n  }\n\n  /**\n   * Force refresh of all data\n   */\n  public async forceRefresh(): Promise<void> {\n    await Promise.all([\n      this.pollLiveGames(),\n      this.pollPlayerUpdates(),\n      this.pollOddsUpdates()\n    ]);\n  }\n\n  /**\n   * Start real-time monitoring\n   */\n  public start(): void {\n    if (!this.wsConnection.isConnected) {\n      this.initializeConnection();\n    }\n    console.log('üöÄ Real-time NFL data service started');\n  }\n\n  /**\n   * Stop real-time monitoring\n   */\n  public stop(): void {\n    // Clear all intervals\n    Object.values(this.intervals).forEach(interval => {\n      clearInterval(interval);\n    });\n    this.intervals = {};\n    \n    // Close WebSocket if connected\n    if (this.wsConnection.socket) {\n      this.wsConnection.socket.close();\n      this.wsConnection.socket = null;\n    }\n    \n    this.wsConnection.isConnected = false;\n    console.log('üõë Real-time NFL data service stopped');\n  }\n\n  /**\n   * Get connection status\n   */\n  public getConnectionStatus(): { isConnected: boolean; reconnectAttempts: number; subscriptions: number } {\n    return {\n      isConnected: this.wsConnection.isConnected,\n      reconnectAttempts: this.wsConnection.reconnectAttempts,\n      subscriptions: this.wsConnection.subscriptions.size\n    };\n  }\n}\n\n// Export singleton instance\nexport const realTimeNflDataService = new RealTimeNflDataService();\n","/**\n * Oracle Live Data Integration Service\n * Integrates real-time NFL data with Oracle ML prediction services for dynamic updates\n * Manages prediction confidence adjustments and real-time Oracle intelligence\n */\n\nimport { realTimeNflDataService } from './realTimeNflDataService';\nimport type { \n  RealTimeGameEvent, \n  LivePlayerUpdate,\n  RealTimeEventType\n} from './realTimeNflDataService';\nimport type { OraclePrediction } from './oraclePredictionService';\n\nexport interface LivePredictionUpdate {\n  predictionId: string;\n  oldConfidence: number;\n  newConfidence: number;\n  reason: string;\n  dataSource: string;\n  timestamp: number;\n  impact: 'positive' | 'negative' | 'neutral';\n}\n\nexport interface OracleIntelligenceUpdate {\n  type: 'confidence_change' | 'new_insight' | 'data_alert' | 'trend_detected';\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  title: string;\n  message: string;\n  affectedPredictions: string[];\n  data: any;\n  timestamp: number;\n}\n\nexport interface LiveOracleMetrics {\n  totalPredictions: number;\n  activePredictions: number;\n  averageConfidence: number;\n  confidenceChanges: number;\n  dataPointsProcessed: number;\n  lastUpdated: number;\n  realtimeAccuracy: number;\n  trendsDetected: number;\n}\n\nclass OracleLiveDataIntegrationService {\n  private isActive = false;\n  private readonly predictionUpdates = new Map<string, LivePredictionUpdate[]>();\n  private readonly intelligenceUpdates: OracleIntelligenceUpdate[] = [];\n  private metrics: LiveOracleMetrics = {\n    totalPredictions: 0,\n    activePredictions: 0,\n    averageConfidence: 0,\n    confidenceChanges: 0,\n    dataPointsProcessed: 0,\n    lastUpdated: Date.now(),\n    realtimeAccuracy: 0,\n    trendsDetected: 0\n  };\n\n  private readonly listeners = new Map<string, Set<(data: any) => void>>();\n  private readonly currentPredictions = new Map<string, OraclePrediction>();\n  \n  constructor() {\n    this.setupEventListeners();\n  }\n\n  /**\n   * Set up event listeners for real-time data events\n   */\n  private setupEventListeners(): void {\n    // Listen to game events\n    realTimeNflDataService.subscribe('game_event', (event: RealTimeGameEvent) => {\n      this.handleGameEvent(event);\n    });\n\n    // Listen to score updates\n    realTimeNflDataService.subscribe('score_update', (data: any) => {\n      this.handleScoreUpdate(data);\n    });\n\n    // Listen to player updates\n    realTimeNflDataService.subscribe('player_update', (update: LivePlayerUpdate) => {\n      this.handlePlayerUpdate(update);\n    });\n\n    // Listen to player injuries\n    realTimeNflDataService.subscribe('player_injury', (data: any) => {\n      this.handlePlayerInjury(data);\n    });\n\n    // Listen to odds updates\n    realTimeNflDataService.subscribe('odds_update', (data: any) => {\n      this.handleOddsUpdate(data);\n    });\n  }\n\n  /**\n   * Handle game events and update Oracle predictions\n   */\n  private async handleGameEvent(event: RealTimeGameEvent): Promise<void> {\n    try {\n      const affectedPredictions = await this.findAffectedPredictions(event.gameId);\n      \n      for (const prediction of affectedPredictions) {\n        const confidenceAdjustment = this.calculateConfidenceAdjustment(event, prediction);\n        \n        if (Math.abs(confidenceAdjustment) > 0.01) { // Only update if change is significant\n          const oldConfidence = prediction.confidence;\n          const newConfidence = Math.max(0.6, Math.min(0.95, oldConfidence + confidenceAdjustment));\n          \n          // Update prediction confidence\n          prediction.confidence = newConfidence;\n          this.currentPredictions.set(prediction.id, prediction);\n          \n          // Record the update\n          const update: LivePredictionUpdate = {\n            predictionId: prediction.id,\n            oldConfidence,\n            newConfidence,\n            reason: this.getConfidenceChangeReason(event, confidenceAdjustment),\n            dataSource: 'live_game_event',\n            timestamp: Date.now(),\n            impact: confidenceAdjustment > 0 ? 'positive' : 'negative'\n          };\n          \n          this.recordPredictionUpdate(update);\n          \n          // Generate intelligence update\n          const intelligenceUpdate: OracleIntelligenceUpdate = {\n            type: 'confidence_change',\n            severity: Math.abs(confidenceAdjustment) > 0.05 ? 'high' : 'medium',\n            title: 'Live Data Impact',\n            message: `${event.data.description} affecting prediction confidence`,\n            affectedPredictions: [prediction.id],\n            data: { event, confidenceAdjustment },\n            timestamp: Date.now()\n          };\n          \n          this.addIntelligenceUpdate(intelligenceUpdate);\n        }\n      }\n      \n      this.updateMetrics();\n      this.emit('predictions_updated', { affectedPredictions: affectedPredictions.map(p => p.id) });\n      \n    } catch (error) {\n      console.error('‚ùå Error handling game event:', error);\n    }\n  }\n\n  /**\n   * Handle score updates\n   */\n  private async handleScoreUpdate(data: { gameId: string; homeScore: number; awayScore: number; timestamp: number }): Promise<void> {\n    try {\n      const affectedPredictions = await this.findAffectedPredictions(data.gameId);\n      \n      for (const prediction of affectedPredictions) {\n        if (prediction.type === 'GAME_OUTCOME' || prediction.type === 'PLAYER_PERFORMANCE') {\n          // Recalculate confidence based on current score\n          const confidenceAdjustment = this.calculateScoreBasedConfidenceAdjustment(data, prediction);\n          \n          if (Math.abs(confidenceAdjustment) > 0.02) {\n            const oldConfidence = prediction.confidence;\n            const newConfidence = Math.max(0.6, Math.min(0.95, oldConfidence + confidenceAdjustment));\n            \n            prediction.confidence = newConfidence;\n            this.currentPredictions.set(prediction.id, prediction);\n            \n            const update: LivePredictionUpdate = {\n              predictionId: prediction.id,\n              oldConfidence,\n              newConfidence,\n              reason: `Score update: ${data.homeScore}-${data.awayScore}`,\n              dataSource: 'live_score_update',\n              timestamp: Date.now(),\n              impact: confidenceAdjustment > 0 ? 'positive' : 'negative'\n            };\n            \n            this.recordPredictionUpdate(update);\n          }\n        }\n      }\n      \n      this.updateMetrics();\n      this.emit('score_updated', data);\n      \n    } catch (error) {\n      console.error('‚ùå Error handling score update:', error);\n    }\n  }\n\n  /**\n   * Handle player updates\n   */\n  private async handlePlayerUpdate(update: LivePlayerUpdate): Promise<void> {\n    try {\n      const affectedPredictions = await this.findPlayerAffectedPredictions(update.playerId);\n      \n      for (const prediction of affectedPredictions) {\n        const confidenceAdjustment = this.calculatePlayerBasedConfidenceAdjustment(update, prediction);\n        \n        if (Math.abs(confidenceAdjustment) > 0.01) {\n          const oldConfidence = prediction.confidence;\n          const newConfidence = Math.max(0.6, Math.min(0.95, oldConfidence + confidenceAdjustment));\n          \n          prediction.confidence = newConfidence;\n          this.currentPredictions.set(prediction.id, prediction);\n          \n          const updateRecord: LivePredictionUpdate = {\n            predictionId: prediction.id,\n            oldConfidence,\n            newConfidence,\n            reason: `Player performance update: ${update.name} (${update.stats.fantasyPoints} fantasy pts)`,\n            dataSource: 'live_player_update',\n            timestamp: Date.now(),\n            impact: confidenceAdjustment > 0 ? 'positive' : 'negative'\n          };\n          \n          this.recordPredictionUpdate(updateRecord);\n        }\n      }\n      \n      this.updateMetrics();\n      this.emit('player_updated', update);\n      \n    } catch (error) {\n      console.error('‚ùå Error handling player update:', error);\n    }\n  }\n\n  /**\n   * Handle player injury updates\n   */\n  private async handlePlayerInjury(data: { playerId: string; name: string; team: string; oldStatus: string; newStatus: string; timestamp: number }): Promise<void> {\n    try {\n      const affectedPredictions = await this.findPlayerAffectedPredictions(data.playerId);\n      \n      const severityMap = {\n        'healthy': 0,\n        'questionable': -0.02,\n        'doubtful': -0.05,\n        'out': -0.1\n      };\n      \n      const confidenceAdjustment = (severityMap[data.newStatus as keyof typeof severityMap] || 0) - \n                                  (severityMap[data.oldStatus as keyof typeof severityMap] || 0);\n      \n      for (const prediction of affectedPredictions) {\n        const oldConfidence = prediction.confidence;\n        const newConfidence = Math.max(0.6, Math.min(0.95, oldConfidence + confidenceAdjustment));\n        \n        prediction.confidence = newConfidence;\n        this.currentPredictions.set(prediction.id, prediction);\n        \n        const update: LivePredictionUpdate = {\n          predictionId: prediction.id,\n          oldConfidence,\n          newConfidence,\n          reason: `Injury status change: ${data.name} (${data.oldStatus} ‚Üí ${data.newStatus})`,\n          dataSource: 'player_injury_update',\n          timestamp: Date.now(),\n          impact: confidenceAdjustment > 0 ? 'positive' : 'negative'\n        };\n        \n        this.recordPredictionUpdate(update);\n      }\n      \n      // Generate critical intelligence update for injuries\n      const intelligenceUpdate: OracleIntelligenceUpdate = {\n        type: 'data_alert',\n        severity: data.newStatus === 'out' ? 'critical' : 'high',\n        title: 'Player Injury Alert',\n        message: `${data.name} (${data.team}) status changed from ${data.oldStatus} to ${data.newStatus}`,\n        affectedPredictions: affectedPredictions.map(p => p.id),\n        data,\n        timestamp: Date.now()\n      };\n      \n      this.addIntelligenceUpdate(intelligenceUpdate);\n      this.updateMetrics();\n      this.emit('player_injury', data);\n      \n    } catch (error) {\n      console.error('‚ùå Error handling player injury:', error);\n    }\n  }\n\n  /**\n   * Handle odds updates\n   */\n  private async handleOddsUpdate(data: any): Promise<void> {\n    try {\n      const affectedPredictions = await this.findAffectedPredictions(data.gameId);\n      \n      for (const prediction of affectedPredictions) {\n        if (prediction.type === 'GAME_OUTCOME') {\n          // Adjust confidence based on odds movement\n          const confidenceAdjustment = this.calculateOddsBasedConfidenceAdjustment(data.odds, prediction);\n          \n          if (Math.abs(confidenceAdjustment) > 0.01) {\n            const oldConfidence = prediction.confidence;\n            const newConfidence = Math.max(0.6, Math.min(0.95, oldConfidence + confidenceAdjustment));\n            \n            prediction.confidence = newConfidence;\n            this.currentPredictions.set(prediction.id, prediction);\n            \n            const update: LivePredictionUpdate = {\n              predictionId: prediction.id,\n              oldConfidence,\n              newConfidence,\n              reason: 'Betting odds movement detected',\n              dataSource: 'odds_update',\n              timestamp: Date.now(),\n              impact: confidenceAdjustment > 0 ? 'positive' : 'negative'\n            };\n            \n            this.recordPredictionUpdate(update);\n          }\n        }\n      }\n      \n      this.updateMetrics();\n      this.emit('odds_updated', data);\n      \n    } catch (error) {\n      console.error('‚ùå Error handling odds update:', error);\n    }\n  }\n\n  /**\n   * Calculate confidence adjustment based on game events\n   */\n  private calculateConfidenceAdjustment(event: RealTimeGameEvent, prediction: OraclePrediction): number {\n    const eventTypeAdjustments: { [key in RealTimeEventType]: number } = {\n      'GAME_START': 0.01,\n      'SCORE_UPDATE': 0.02,\n      'PLAYER_INJURY': -0.05,\n      'PLAYER_STATUS_CHANGE': -0.02,\n      'WEATHER_UPDATE': -0.01,\n      'ODDS_UPDATE': 0.015,\n      'QUARTER_END': 0.005,\n      'GAME_END': 0,\n      'TIMEOUT': 0,\n      'PENALTY': -0.005,\n      'TURNOVER': 0.03,\n      'RED_ZONE_ENTRY': 0.02\n    };\n    \n    const baseAdjustment = eventTypeAdjustments[event.type] || 0;\n    \n    let severityMultiplier: number;\n    if (event.data.severity === 'critical') {\n      severityMultiplier = 2;\n    } else if (event.data.severity === 'high') {\n      severityMultiplier = 1.5;\n    } else if (event.data.severity === 'medium') {\n      severityMultiplier = 1;\n    } else {\n      severityMultiplier = 0.5;\n    }\n    \n    let impactMultiplier: number;\n    if (event.data.impact === 'positive') {\n      impactMultiplier = 1;\n    } else if (event.data.impact === 'negative') {\n      impactMultiplier = -1;\n    } else {\n      impactMultiplier = 0;\n    }\n    \n    return baseAdjustment * severityMultiplier * impactMultiplier;\n  }\n\n  /**\n   * Calculate confidence adjustment based on score updates\n   */\n  private calculateScoreBasedConfidenceAdjustment(data: { homeScore: number; awayScore: number }, prediction: OraclePrediction): number {\n    // Simple logic - in production this would be more sophisticated\n    const scoreDifference = Math.abs(data.homeScore - data.awayScore);\n    const largeScoreDifference = scoreDifference > 14;\n    \n    if (prediction.type === 'GAME_OUTCOME') {\n      return largeScoreDifference ? 0.03 : 0.01;\n    }\n    \n    return 0;\n  }\n\n  /**\n   * Calculate confidence adjustment based on player updates\n   */\n  private calculatePlayerBasedConfidenceAdjustment(update: LivePlayerUpdate, prediction: OraclePrediction): number {\n    if (prediction.type === 'PLAYER_PERFORMANCE') {\n      const fantasyPoints = update.stats.fantasyPoints;\n      \n      if (fantasyPoints > 20) return 0.03;\n      if (fantasyPoints > 15) return 0.02;\n      if (fantasyPoints > 10) return 0.01;\n      if (fantasyPoints < 5) return -0.02;\n    }\n    \n    return 0;\n  }\n\n  /**\n   * Calculate confidence adjustment based on odds\n   */\n  private calculateOddsBasedConfidenceAdjustment(odds: any, prediction: OraclePrediction): number {\n    // Simple implementation - in production this would analyze odds movement\n    return 0.01;\n  }\n\n  /**\n   * Find predictions affected by a game\n   */\n  private async findAffectedPredictions(gameId: string): Promise<OraclePrediction[]> {\n    const allPredictions = Array.from(this.currentPredictions.values());\n    return allPredictions.filter(prediction => \n      prediction.question.toLowerCase().includes(gameId.toLowerCase())\n    );\n  }\n\n  /**\n   * Find predictions affected by a player\n   */\n  private async findPlayerAffectedPredictions(playerId: string): Promise<OraclePrediction[]> {\n    const allPredictions = Array.from(this.currentPredictions.values());\n    return allPredictions.filter(prediction => \n      prediction.question.toLowerCase().includes(playerId.toLowerCase())\n    );\n  }\n\n  /**\n   * Get confidence change reason\n   */\n  private getConfidenceChangeReason(event: RealTimeGameEvent, adjustment: number): string {\n    const direction = adjustment > 0 ? 'increased' : 'decreased';\n    return `Confidence ${direction} due to ${event.data.description}`;\n  }\n\n  /**\n   * Record prediction update\n   */\n  private recordPredictionUpdate(update: LivePredictionUpdate): void {\n    if (!this.predictionUpdates.has(update.predictionId)) {\n      this.predictionUpdates.set(update.predictionId, []);\n    }\n    \n    const updates = this.predictionUpdates.get(update.predictionId);\n    if (updates) {\n      updates.push(update);\n      \n      // Keep only last 50 updates per prediction\n      if (updates.length > 50) {\n        updates.splice(0, updates.length - 50);\n      }\n    }\n  }\n\n  /**\n   * Add intelligence update\n   */\n  private addIntelligenceUpdate(update: OracleIntelligenceUpdate): void {\n    this.intelligenceUpdates.unshift(update);\n    \n    // Keep only last 100 intelligence updates\n    if (this.intelligenceUpdates.length > 100) {\n      this.intelligenceUpdates.splice(100);\n    }\n    \n    this.emit('intelligence_update', update);\n  }\n\n  /**\n   * Update metrics\n   */\n  private updateMetrics(): void {\n    const activePredictions = Array.from(this.currentPredictions.values());\n    \n    this.metrics = {\n      totalPredictions: activePredictions.length,\n      activePredictions: activePredictions.length, // All predictions are considered active since we don't have status\n      averageConfidence: activePredictions.reduce((sum, p) => sum + p.confidence, 0) / activePredictions.length || 0,\n      confidenceChanges: Array.from(this.predictionUpdates.values()).reduce((sum, updates) => sum + updates.length, 0),\n      dataPointsProcessed: this.metrics.dataPointsProcessed + 1,\n      lastUpdated: Date.now(),\n      realtimeAccuracy: this.calculateRealTimeAccuracy(),\n      trendsDetected: this.intelligenceUpdates.filter(u => u.type === 'trend_detected').length\n    };\n    \n    this.emit('metrics_updated', this.metrics);\n  }\n\n  /**\n   * Calculate real-time accuracy\n   */\n  private calculateRealTimeAccuracy(): number {\n    // Simple calculation - in production this would be more sophisticated\n    const recentUpdates = this.intelligenceUpdates.slice(0, 20);\n    const positiveUpdates = recentUpdates.filter(u => u.type === 'confidence_change').length;\n    return recentUpdates.length > 0 ? positiveUpdates / recentUpdates.length : 0.85;\n  }\n\n  /**\n   * Subscribe to events\n   */\n  public subscribe(eventType: string, callback: (data: any) => void): void {\n    if (!this.listeners.has(eventType)) {\n      this.listeners.set(eventType, new Set());\n    }\n    const listeners = this.listeners.get(eventType);\n    if (listeners) {\n      listeners.add(callback);\n    }\n  }\n\n  /**\n   * Unsubscribe from events\n   */\n  public unsubscribe(eventType: string, callback: (data: any) => void): void {\n    const listeners = this.listeners.get(eventType);\n    if (listeners) {\n      listeners.delete(callback);\n    }\n  }\n\n  /**\n   * Emit events\n   */\n  private emit(eventType: string, data: any): void {\n    const listeners = this.listeners.get(eventType);\n    if (listeners) {\n      listeners.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error(`‚ùå Error in event listener for ${eventType}:`, error);\n        }\n      });\n    }\n  }\n\n  /**\n   * Start live data integration\n   */\n  public start(): void {\n    if (this.isActive) return;\n    \n    this.isActive = true;\n    realTimeNflDataService.start();\n    \n    console.log('üîÑ Oracle Live Data Integration started');\n    this.emit('service_started', { timestamp: Date.now() });\n  }\n\n  /**\n   * Stop live data integration\n   */\n  public stop(): void {\n    if (!this.isActive) return;\n    \n    this.isActive = false;\n    realTimeNflDataService.stop();\n    \n    console.log('üõë Oracle Live Data Integration stopped');\n    this.emit('service_stopped', { timestamp: Date.now() });\n  }\n\n  /**\n   * Get current metrics\n   */\n  public getMetrics(): LiveOracleMetrics {\n    return { ...this.metrics };\n  }\n\n  /**\n   * Get prediction updates\n   */\n  public getPredictionUpdates(predictionId?: string): LivePredictionUpdate[] {\n    if (predictionId) {\n      return this.predictionUpdates.get(predictionId) || [];\n    }\n    \n    return Array.from(this.predictionUpdates.values()).flat();\n  }\n\n  /**\n   * Get intelligence updates\n   */\n  public getIntelligenceUpdates(limit = 20): OracleIntelligenceUpdate[] {\n    return this.intelligenceUpdates.slice(0, limit);\n  }\n\n  /**\n   * Add prediction to monitoring\n   */\n  public addPrediction(prediction: OraclePrediction): void {\n    this.currentPredictions.set(prediction.id, prediction);\n    this.updateMetrics();\n  }\n\n  /**\n   * Remove prediction from monitoring\n   */\n  public removePrediction(predictionId: string): void {\n    this.currentPredictions.delete(predictionId);\n    this.predictionUpdates.delete(predictionId);\n    this.updateMetrics();\n  }\n\n  /**\n   * Get connection status\n   */\n  public getStatus(): { isActive: boolean; dataServiceStatus: any; predictions: number } {\n    return {\n      isActive: this.isActive,\n      dataServiceStatus: realTimeNflDataService.getConnectionStatus(),\n      predictions: this.currentPredictions.size\n    };\n  }\n}\n\n// Export singleton instance\nexport const oracleLiveDataIntegrationService = new OracleLiveDataIntegrationService();\n","\nimport type { League, Team, GamedayEvent, LiveNewsItem, GamedayEventType } from '../types';\nimport { realTimeNflDataService } from './realTimeNflDataService';\nimport { oracleLiveDataIntegrationService } from './oracleLiveDataIntegrationService';\nimport type { RealTimeGameEvent, LivePlayerUpdate } from './realTimeNflDataService';\n\n// This is a singleton to provide live data integration across the application\nclass LiveDataService {\n    private intervalId: ReturnType<typeof setInterval> | null = null;\n    private listeners: ((event: GamedayEvent | LiveNewsItem) => void)[] = [];\n    private isActive = false;\n\n    constructor() {\n        this.setupRealTimeListeners();\n    }\n\n    /**\n     * Set up listeners for real-time NFL data events\n     */\n    private setupRealTimeListeners(): void {\n        // Listen to real-time game events and convert to app events\n        realTimeNflDataService.subscribe('game_event', (event: RealTimeGameEvent) => {\n            const gamedayEvent: GamedayEvent = {\n                id: event.id,\n                type: this.convertEventType(event.type),\n                timestamp: event.timestamp,\n                text: event.data.description,\n                teamId: 1, // Default team ID\n                player: {\n                    id: parseInt(event.data.playerId || '1'),\n                    name: event.data.playerName || 'Player',\n                    position: 'RB',\n                    team: event.data.team || 'NFL',\n                    rank: 1,\n                    adp: 1,\n                    bye: 0,\n                    tier: 1,\n                    age: 25,\n                    auctionValue: 1,\n                    stats: {\n                        projection: 0,\n                        lastYear: 0,\n                        vorp: 0,\n                        weeklyProjections: {}\n                    }\n                },\n                points: 0\n            };\n            \n            this.emit(gamedayEvent);\n        });\n\n        // Listen to player updates\n        realTimeNflDataService.subscribe('player_update', (update: LivePlayerUpdate) => {\n            const gamedayEvent: GamedayEvent = {\n                id: `player_update_${update.playerId}_${Date.now()}`,\n                type: 'BIG_PLAY',\n                timestamp: update.lastUpdated,\n                text: `${update.name} has ${update.stats.fantasyPoints} fantasy points`,\n                teamId: 1,\n                player: {\n                    id: parseInt(update.playerId.replace(/\\D/g, '') || '1'),\n                    name: update.name,\n                    position: update.position as any || 'RB',\n                    team: update.team,\n                    rank: 1,\n                    adp: 1,\n                    bye: 0,\n                    tier: 1,\n                    age: 25,\n                    auctionValue: 1,\n                    stats: {\n                        projection: update.stats.fantasyPoints,\n                        lastYear: 0,\n                        vorp: 0,\n                        weeklyProjections: {}\n                    }\n                },\n                points: update.stats.fantasyPoints\n            };\n            \n            this.emit(gamedayEvent);\n        });\n\n        // Listen to player injuries\n        realTimeNflDataService.subscribe('player_injury', (data: any) => {\n            const gamedayEvent: GamedayEvent = {\n                id: `injury_${data.playerId}_${Date.now()}`,\n                type: 'FUMBLE', // Using closest available type for negative events\n                timestamp: data.timestamp,\n                text: `${data.name} injury status: ${data.oldStatus} ‚Üí ${data.newStatus}`,\n                teamId: 1,\n                player: {\n                    id: parseInt(data.playerId.replace(/\\D/g, '') || '1'),\n                    name: data.name,\n                    position: 'RB',\n                    team: data.team,\n                    rank: 1,\n                    adp: 1,\n                    bye: 0,\n                    tier: 1,\n                    age: 25,\n                    auctionValue: 1,\n                    stats: {\n                        projection: 0,\n                        lastYear: 0,\n                        vorp: 0,\n                        weeklyProjections: {}\n                    }\n                },\n                points: -5 // Negative points for injury\n            };\n            \n            this.emit(gamedayEvent);\n        });\n\n        // Listen to Oracle intelligence updates\n        oracleLiveDataIntegrationService.subscribe('intelligence_update', (update: any) => {\n            const newsItem: LiveNewsItem = {\n                id: `oracle_${Date.now()}`,\n                date: new Date(update.timestamp).toISOString(),\n                headline: update.title,\n                source: 'Oracle AI'\n            };\n            \n            this.emit(newsItem);\n        });\n    }\n\n    /**\n     * Convert real-time event types to app event types\n     */\n    private convertEventType(eventType: string): GamedayEventType {\n        const eventTypeMap: { [key: string]: GamedayEventType } = {\n            'SCORE_UPDATE': 'TOUCHDOWN',\n            'PLAYER_INJURY': 'FUMBLE',\n            'TURNOVER': 'FUMBLE',\n            'RED_ZONE_ENTRY': 'REDZONE_ENTRY',\n            'GAME_START': 'BIG_PLAY',\n            'GAME_END': 'BIG_PLAY',\n            'QUARTER_END': 'BIG_PLAY'\n        };\n        \n        return eventTypeMap[eventType] || 'BIG_PLAY';\n    }\n\n    start(league: League, myTeam: Team, opponentTeam: Team) {\n        if (this.intervalId) {\n            this.stop();\n        }\n        \n        this.isActive = true;\n        \n        // Start real-time services\n        realTimeNflDataService.start();\n        oracleLiveDataIntegrationService.start();\n        \n        console.log('üöÄ Live Data Service started with real-time integration');\n        \n        // Generate initial welcome event\n        this.emit({\n            id: 'welcome_live_data',\n            type: 'BIG_PLAY',\n            timestamp: Date.now(),\n            text: 'Real-time NFL data and Oracle insights are now active',\n            teamId: 1,\n            player: {\n                id: 1,\n                name: 'Oracle System',\n                position: 'QB',\n                team: 'NFL',\n                rank: 1,\n                adp: 1,\n                bye: 0,\n                tier: 1,\n                age: 25,\n                auctionValue: 1,\n                stats: {\n                    projection: 0,\n                    lastYear: 0,\n                    vorp: 0,\n                    weeklyProjections: {}\n                }\n            },\n            points: 5\n        });\n    }\n\n    stop() {\n        if (this.intervalId) {\n            window.clearInterval(this.intervalId);\n            this.intervalId = null;\n        }\n        \n        this.isActive = false;\n        \n        // Stop real-time services\n        realTimeNflDataService.stop();\n        oracleLiveDataIntegrationService.stop();\n        \n        console.log('üõë Live Data Service stopped');\n    }\n\n    subscribe(listener: (event: GamedayEvent | LiveNewsItem) => void) {\n        this.listeners.push(listener);\n    }\n\n    unsubscribe(listener: (event: GamedayEvent | LiveNewsItem) => void) {\n        this.listeners = this.listeners.filter(l => l !== listener);\n    }\n\n    private emit(event: GamedayEvent | LiveNewsItem) {\n        this.listeners.forEach(listener => {\n            try {\n                listener(event);\n            } catch (error) {\n                console.error('‚ùå Error in live data listener:', error);\n            }\n        });\n    }\n\n    /**\n     * Get connection status for all live data services\n     */\n    getStatus() {\n        return {\n            isActive: this.isActive,\n            realTimeNfl: realTimeNflDataService.getConnectionStatus(),\n            oracleIntegration: oracleLiveDataIntegrationService.getStatus(),\n            listeners: this.listeners.length\n        };\n    }\n\n    /**\n     * Force refresh all live data\n     */\n    async forceRefresh() {\n        if (this.isActive) {\n            await realTimeNflDataService.forceRefresh();\n        }\n    }\n}\n\n// Export a single instance to be used across the app\nexport const liveDataService = new LiveDataService();\n","\nimport React from 'react';\nimport { useAppState } from '../contexts/AppContext';\nimport { liveDataService } from '../services/liveDataService';\nimport type { League, Team, GamedayEvent, LiveNewsItem } from '../types';\n\nexport const useLiveData = (league?: League, myTeam?: Team, opponentTeam?: Team) => {\n    const { state, dispatch } = useAppState();\n    const [latestNews, setLatestNews] = React.useState<LiveNewsItem | null>(null);\n\n    React.useEffect(() => {\n        // Only start the service if we are on the MATCHUP view and have all the data.\n        if (state.currentView === 'MATCHUP' && league && myTeam && opponentTeam) {\n            const handleEvent = (event: GamedayEvent | LiveNewsItem) => {\n                if ('type' in event && 'player' in event) { // It's a GamedayEvent\n                    const matchup = league.schedule.find(m =>\n                        m.week === league.currentWeek &&\n                        (m.teamA.teamId === myTeam.id || m.teamB.teamId === myTeam.id)\n                    );\n                    if (matchup) {\n                        dispatch({\n                            type: 'ADD_GAMEDAY_EVENT',\n                            payload: { matchupId: matchup.id, event }\n                        });\n                    }\n                } else { // It's a LiveNewsItem\n                    setLatestNews(event as LiveNewsItem);\n                }\n            };\n            \n            liveDataService.subscribe(handleEvent);\n            liveDataService.start(league, myTeam, opponentTeam);\n\n            return () => {\n                liveDataService.unsubscribe(handleEvent);\n                liveDataService.stop();\n            };\n        } else {\n             // Ensure the service is stopped if we navigate away or data is missing.\n             liveDataService.stop();\n        }\n    }, [league, myTeam, opponentTeam, dispatch, state.currentView]);\n\n    return { latestNews };\n};\n"],"names":["RealTimeNflDataService","__publicField","liveGames","productionSportsDataService","game","cachedGame","events","playerUpdates","liveGameData","event","e","error","player","cached","liveUpdate","games","oldGame","newGame","oldPlayer","newPlayer","playerId","gameId","now","seasonStart","weeksSinceStart","eventType","callback","listeners","data","interval","realTimeNflDataService","OracleLiveDataIntegrationService","update","affectedPredictions","prediction","confidenceAdjustment","oldConfidence","newConfidence","intelligenceUpdate","p","updateRecord","severityMap","baseAdjustment","severityMultiplier","impactMultiplier","largeScoreDifference","fantasyPoints","odds","adjustment","updates","activePredictions","sum","u","recentUpdates","positiveUpdates","predictionId","limit","oracleLiveDataIntegrationService","LiveDataService","gamedayEvent","newsItem","league","myTeam","opponentTeam","listener","l","liveDataService","useLiveData","state","dispatch","useAppState","latestNews","setLatestNews","React","handleEvent","matchup","m"],"mappings":"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"}